import { DatabaseCollectionImplementation, DbKey } from "./DatabaseDefinition";
import { DatabaseFilter } from "./DatabaseFilters";
import { DatabaseSortExpression } from "./DatabaseSorters";
import { Listener } from "./Listeners";
export declare enum ObservableDbEvents {
    OBS_DB_COLLECTION_ADD = "OBS_DB_COLLECTION_ADD",
    OBS_DB_COLLECTION_PUT = "OBS_DB_COLLECTION_PUT",
    OBS_DB_COLLECTION_DEL = "OBS_DB_COLLECTION_DEL",
    OBS_DB_COLLECTION_CLEAR = "OBS_DB_COLLECTION_CLEAR"
}
export interface ObservableDbKeyInfo {
    db: string;
    version: number;
    collection: string;
    key: DbKey;
}
export interface ObservableDbRecordInfo extends ObservableDbKeyInfo {
    record: any;
}
export declare type ObservableDbEventInfo = ObservableDbKeyInfo | ObservableDbRecordInfo;
export declare class ObservableDbCollection<T> implements DatabaseCollectionImplementation<T> {
    private collection;
    private listeners;
    private notifyAdd;
    private notifyPut;
    private notifyDel;
    constructor(collection: DatabaseCollectionImplementation<T>);
    clear(): Promise<unknown>;
    getDatabaseName(): string;
    getDatabaseVersion(): number;
    getName(): string;
    getKeyPath(): string | string[];
    isKeyAutoGenerated(): boolean;
    add(record: T): Promise<DbKey>;
    addBatch(records: T[]): Promise<DbKey[]>;
    putBatch(records: T[]): Promise<DbKey[]>;
    put(record: T): Promise<DbKey>;
    delete(key: DbKey): Promise<unknown>;
    get(key: DbKey): Promise<T>;
    all(): Promise<T[]>;
    filter(fn: (record: T) => boolean): Promise<T[]>;
    map<G>(fn: (Record: T) => G): Promise<G[]>;
    forEach(fn: (record: T) => void): Promise<unknown>;
    count(): Promise<number>;
    query(filter?: DatabaseFilter, sort?: DatabaseSortExpression, offset?: number, limit?: number): Promise<T[]>;
    addListener(event: ObservableDbEvents, listener: Listener): void;
    removeListener(event: ObservableDbEvents, listener: Listener): void;
}
