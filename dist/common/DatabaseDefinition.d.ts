import { DatabaseFilter } from "./DatabaseFilters";
import { DatabaseSortExpression } from "./DatabaseSorters";
/**
 * A database key can only be a number or a string.
 * At least so far (at this point, no dates or arrays are allowed).
 *
 * @author Rodrigo Portela
 */
export declare type DbKey = number | string;
/**
 * One way to create a time ascending unique identifier.
 * Should suffice for most cases but some may require a less naive approach.
 *
 * @author Rodrigo Portela
 */
export declare const createId: () => string;
/**
 * This is a collection schema.
 * It describes what's necessary to deploy a data schema.
 * Important to notice that you don't have to describe the columns.
 *
 * @author Rodrigo Portela
 */
export interface DatabaseCollectionSchema {
    name: string;
    keyPath: string | string[];
    autoGenerated?: boolean;
}
/**
 * This is the definition of a database.
 * The name, version and what collections it has.
 *
 * @author Rodrigo Portela'
 */
export interface DatabaseSchema {
    name: string;
    version: number;
    collections: DatabaseCollectionSchema[];
}
/**
 * This defines the implementation of a collection/table in a database.
 * It enumerates the methods that should be coded on client databases.
 * Any change here should reflect on all implementations.
 *
 * @author Rodrigo Portela
 */
export interface DatabaseCollectionImplementation<T> {
    getDatabaseName(): string;
    getDatabaseVersion(): number;
    getName(): string;
    getKeyPath(): string | string[];
    isKeyAutoGenerated(): boolean;
    add(record: T): Promise<DbKey>;
    addBatch(records: T[]): Promise<DbKey[]>;
    put(record: T): Promise<DbKey>;
    putBatch(records: T[]): Promise<DbKey[]>;
    delete(key: DbKey): Promise<unknown>;
    get(key: DbKey): Promise<T>;
    all(): Promise<T[]>;
    filter(fn: (record: T) => boolean): Promise<T[]>;
    map<G>(fn: (record: T) => any): Promise<G[]>;
    forEach(fn: (record: T) => void): Promise<unknown>;
    count(): Promise<number>;
    query(filter: DatabaseFilter, sort?: DatabaseSortExpression, offset?: number, limit?: number): Promise<T[]>;
}
/**
 * This defines the implementation of a database.
 * It enumerates the methods that should be coded on client databases.
 * Any change here should reflect on all implementations.
 *
 * @author Rodrigo Portela
 */
export interface DatabaseImplementation {
    getName(): string;
    getVersion(): number;
    getCollections(): Promise<DatabaseCollectionImplementation<any>[]>;
    getCollection<T>(name: string): Promise<DatabaseCollectionImplementation<T>>;
    drop(): Promise<unknown>;
    getSchema(): DatabaseSchema;
}
