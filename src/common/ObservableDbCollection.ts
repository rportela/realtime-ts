import { DatabaseCollectionImplementation, DbKey } from "./DatabaseDefinition";
import { DatabaseFilter } from "./DatabaseFilters";
import { DatabaseSortExpression } from "./DatabaseSorters";
import { Listener, Listeners } from "./Listeners";

export enum ObservableDbEvents {
  OBS_DB_COLLECTION_ADD = "OBS_DB_COLLECTION_ADD",
  OBS_DB_COLLECTION_PUT = "OBS_DB_COLLECTION_PUT",
  OBS_DB_COLLECTION_DEL = "OBS_DB_COLLECTION_DEL",
}

export interface ObservableDbKeyInfo {
  db: string;
  version: number;
  collection: string;
  key: DbKey;
}

export interface ObservableDbRecordInfo extends ObservableDbKeyInfo {
  record: any;
}

export type ObservableDbEventInfo =
  | ObservableDbKeyInfo
  | ObservableDbRecordInfo;

export class ObservableDbCollection<T>
  implements DatabaseCollectionImplementation<T> {
  private collection: DatabaseCollectionImplementation<T>;
  private listeners: Listeners;

  private notifyAdd = (record: T, key: DbKey) => {
    this.listeners.notify(ObservableDbEvents.OBS_DB_COLLECTION_ADD, {
      db: this.collection.getDatabaseName(),
      version: this.collection.getDatabaseVersion(),
      collection: this.collection.getName(),
      record: record,
      key: key,
    });
    return key;
  };

  private notifyPut = (record: T, key: DbKey) => {
    this.listeners.notify(ObservableDbEvents.OBS_DB_COLLECTION_PUT, {
      db: this.collection.getDatabaseName(),
      version: this.collection.getDatabaseVersion(),
      collection: this.collection.getName(),
      record: record,
      key: key,
    });
    return key;
  };

  private notifyDel = (key: DbKey) => {
    this.listeners.notify(ObservableDbEvents.OBS_DB_COLLECTION_DEL, {
      db: this.collection.getDatabaseName(),
      version: this.collection.getDatabaseVersion(),
      collection: this.collection.getName(),
      key: key,
    });
    return key;
  };

  constructor(collection: DatabaseCollectionImplementation<T>) {
    this.collection = collection;
    this.listeners = new Listeners();
  }

  getDatabaseName() {
    return this.collection.getDatabaseName();
  }
  getDatabaseVersion() {
    return this.collection.getDatabaseVersion();
  }
  getName(): string {
    return this.collection.getName();
  }
  getKeyPath(): string | string[] {
    return this.collection.getKeyPath();
  }
  isKeyAutoGenerated(): boolean {
    return this.collection.isKeyAutoGenerated();
  }
  add(record: T): Promise<DbKey> {
    return this.collection
      .add(record)
      .then((key) => this.notifyAdd(record, key));
  }
  addBatch(records: T[]): Promise<DbKey[]> {
    return this.collection.addBatch(records).then((keys) => {
      for (let i = 0; i < keys.length; i++) this.notifyAdd(records[i], keys[i]);
      return keys;
    });
  }
  putBatch(records: T[]): Promise<DbKey[]> {
    return this.collection.putBatch(records).then((keys) => {
      for (let i = 0; i < keys.length; i++) this.notifyAdd(records[i], keys[i]);
      return keys;
    });
  }
  put(record: T): Promise<DbKey> {
    return this.collection
      .put(record)
      .then((key) => this.notifyPut(record, key));
  }
  delete(key: DbKey): Promise<unknown> {
    return this.collection.delete(key).then(this.notifyDel);
  }
  get(key: DbKey): Promise<T> {
    return this.collection.get(key);
  }
  all(): Promise<T[]> {
    return this.collection.all();
  }
  filter(fn: (record: T) => boolean): Promise<T[]> {
    return this.collection.filter(fn);
  }
  map<G>(fn: (Record: T) => G): Promise<G[]> {
    return this.collection.map(fn);
  }
  forEach(fn: (record: T) => void): Promise<unknown> {
    return this.collection.forEach(fn);
  }
  count(): Promise<number> {
    return this.collection.count();
  }
  query(
    filter?: DatabaseFilter,
    sort?: DatabaseSortExpression,
    offset?: number,
    limit?: number
  ): Promise<T[]> {
    return this.collection.query(filter, sort, offset, limit);
  }

  addListener(event: ObservableDbEvents, listener: Listener) {
    this.listeners.addListener(event, listener);
  }
  removeListener(event: ObservableDbEvents, listener: Listener) {
    this.listeners.removeListener(event, listener);
  }
}
